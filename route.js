var path = require( 'path' );var fs = require( 'fs' );var Converter = require( './Markdown.Converter' ).Converter;var text2html = new Converter();var include = require( './include' );var log = require( './log' );var mimes= require( './mime' );var mx = require( './mx' );var EXT_NAME = '.markdown';var extnames = [ '.md', '.markdown' ];var default_index = 'index';var default_encode = 'utf8';function write( response, type, data ) {    var html = text2html.makeHtml( data );    var txt = include( './template/index.html' );    html = txt.replace( '{{body}}', html ).replace( '{{title}}', 'redky' );    response.writeHead( 200, { 'Content-Type': mimes[type]} );    response.write( html, 'utf8' );    response.end();}function write404( response ) {    routes['/list']( response, '404' );}function write500( response ) {    routes['/list']( response, '500' );}function staticFile( response, file ) {    var type = path.extname( file );    type = type.slice(1);    fs.readFile( file, function ( error, data ) {        if ( error ) {            write500( response );            return;        }        else {            response.writeHead( 200, { 'Content-Type': mimes[type]} );            response.write( data, 'binary' );            response.end();        }    });}function readEachFile( extname, key ) {    var defer = mx.Deferred();    var default_dir = '/list';        var file = path.join( __dirname, default_index + extname );    if ( key && key != default_index ) {        file = path.join( __dirname, default_dir, key + extname );    }    fs.exists( file, function ( isExist ) {        if ( isExist ) {            fs.readFile( file, default_encode, function (error, data) {                if ( error ) {                    defer.resolve({                        code: 500                    });                    return;                }                defer.resolve({                    type: 'html',                    data: data,                    code: 200                });            });        }        else {            defer.resolve({                code: 404            });        }    });    return defer;}var routes = {    '/': function (response) {        routes['/list']( response );    },    '/list': function ( response, key ) {        var deferList = extnames.map(function ( extname, index ) {            return readEachFile( extname, key );        });        mx.when.apply( mx, deferList ).done(function () {            var results = [].slice.call( arguments );            var result;            for ( var i = 0, l = results.length; i < l; i++ ) {                result = results[i];                for ( var key in result ) {                    if ( result.hasOwnProperty( key ) ) {                        if ( key === 'code' ) {                            switch(result[key]) {                                case 200:                                    write( response, result.type, result.data );                                    return;                                case 500:                                    write500( response );                                    return;                                default:                                    break;                            }                        }                    }                }            }            write404( response );        });    }};function pass( response, pathname, key ) {    var self = arguments.callee;    key = key || default_index;    var realpath = path.join( __dirname, pathname );    var dirRealpathName = path.dirname( realpath );    fs.exists( realpath, function ( isExist ) {        if ( routes[pathname] ) {            routes[pathname]( response, key );            return;        }        // 防止直接访问 __dirname 目录下文件.        // 静态服务器.        if ( isExist && dirRealpathName != __dirname ) {            staticFile( response, realpath );            return;        }        var basename = path.basename( pathname );        var dirname = path.dirname( pathname );        if ( routes[dirname] ) {            routes[dirname]( response, basename );        }        else {            self( response, dirname );        }    });}exports.init = function ( pathname, request, response ) {    pathname = path.normalize( pathname );    pathname = pathname.split( path.sep ).join('/');    pass( response, pathname );};